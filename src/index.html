<!DOCTYPE html>
<html lang="de">

<head>
  <title>Industrie-Microgrid-Demonstrator</title>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="HandheldFriendly" content="true" />

  <!-- tailwind css framework -->
  <!-- <script src="https://cdn.tailwindcss.com"></script> -->

  <!-- custom css dependant from tailwin  -->
  <!-- <link rel="stylesheet" href="customStyles.css"> -->
  <link rel="stylesheet" href="./output.css">

  <!-- 
      dirty import
    -->
  <script src="./node_modules/d3/dist/d3.js"></script>

  <script src="https://unpkg.com/d3-simple-slider@1.7.4/dist/d3-simple-slider.min.js"></script>


  <!-- 
      OpenSoundControl is a data transport specification (an encoding) for realtime message communication among applications and hardware.
      It is used in the TUIO library.
    -->
  <script src="./libs/osc-browser.js"></script>

  <!-- deactivating rightclick on demonstrator, which could be accidently executed by user fingers -->
  <script>
    document.addEventListener('contextmenu', event => {
      event.preventDefault();
    });
  </script>

  <script type="module">
    // internal classes
    import { CsvReader, JsonReader, toMultilineText, wrapTextArray } from "./js/helper.js"
    import { ScenarioState, ScenarioSimulator } from "./js/ScenarioSimulator.js"
    import { Heatpump, PVSystem, Crane, OfficeBuilding, Battery, TrafoClassic, TrafoD3, Wallbox } from "./js/EnergyDevices.js"
    import { TuioListener } from "./js/TuioListener.js"
    import { NodeManager } from "./js/NodeManager.js"
    import { NodeType } from "./js/NodeType.js"
    import { Clock, MagnifyingGlass, Forecasts, EnergyManagementSystem } from "./js/NodeLogic.js"
    import { DevArea, SideBarSmall, Time, InfoBox, TileIconTextGroup } from "./js/GuiElement.js"

    // external
    import { Tuio11Client } from "./libs/tuio11/Tuio11Client.js";
    import { Tuio11Listener } from "./libs/tuio11/Tuio11Listener.js";
    import { WebsocketTuioReceiver } from "./libs/common/WebsocketTuioReceiver.js";
    import { Tuio11Object } from "./libs/tuio11/Tuio11Object.js";
    //import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm"; // D3js Framwork
    // import * as d3 from ("d3");


    var tuioClient
    const tuioListener = new TuioListener(onTuioUpdate)
    var scenario = new ScenarioSimulator()
    const nodeManager = new NodeManager()
    var inSimulation = false
    let currentStep = -1
    let manipulatedData = {}
    let dragged = false

    const config = {
      energy_device_power: [],
      nodes: [],
      websocket_url_tuio_api_box: "",
    }

    globalThis.config = config


    let allSims = new Map()
    // Functions
    function initiateApplicationStart() {
      let jsonConfig = new JsonReader("./data/configuration.json")
      let jsonSimulation0 = new JsonReader("./data/0messages2022-07-23 05_15_00Z.json")
      jsonSimulation0.readFile(loadSimulationData, 0)
      let jsonSimulation1 = new JsonReader("./data/1messages2022-07-23 05_15_00Z.json")
      jsonSimulation1.readFile(loadSimulationData, 1)
      let jsonSimulation2 = new JsonReader("./data/2messages2022-07-23 05_15_00Z.json")
      jsonSimulation2.readFile(loadSimulationData, 2)
      let jsonSimulation3 = new JsonReader("./data/3messages2022-07-23 05_15_00Z.json")
      jsonSimulation3.readFile(loadSimulationData, 3)
      jsonConfig.readFile(applyConfig)
    }

    function loadSimulationData(receivedDict, num) {
      // Apply external simulation data to local data
      let simulation = []
      Object.entries(receivedDict)
        .forEach(([key, value]) => {
          simulation[key] = value
        })
      allSims.set(num, simulation)


    }

    function applyConfig(receivedDict) {
      // Apply external config to local data
      Object.entries(receivedDict).map(([key, value]) => {
        config[key] = value
      })
      start()
    }

    function start() {
      const deviceCsv = new CsvReader(config.energy_device_power_csv)
      deviceCsv.loadCsvFile(parseFile);

      tuioClient = new Tuio11Client(new WebsocketTuioReceiver(config['websocket_url_tuio_api_box']))
      tuioClient.addTuioListener(tuioListener)
      tuioClient.connect()
      nodeManager.simulation = allSims
      tuioListener.simulation = allSims
      scenario.simulationData = allSims
      scenario.scenarioSteps = config.scenario.steps
      scenario.step = config.scenario.start_with_step
      scenario.co2emissionGramPerKwh = config.scenario.co2emission_gram_per_kwh

      sidebar.draw()
      time.draw(function () {
        updateDiagram()
      })

      updateDiagram()
    }

    function onTuioUpdate() {

      nodeManager.getActiveInstances().map((node) => {
        // update scenario devices
        if (node.isActive && node.logic.isTypeOf(NodeType.energyDevice)) {
          scenario.addEnergyDevice(node.instanceId, node)
        } else if (!nodeManager.isInstanceActive(node.instanceId) && node.logic.isTypeOf(NodeType.energyDevice)) {
          scenario.removeEnergyDevice(node.instanceId)
        }

        // update node with latest tuioObject
        if (node.tuioObject) {
          node.x = node.tuioObject.xPos * width
          node.y = node.tuioObject.yPos * height
          node.angle = Math.round((360 / (2 * Math.PI) * node.tuioObject.angle) * 100) / 100

          delete (node.tuioObject)
        }

        // update clock
        if (node.logic.isTypeOf(NodeType.clock) && node.isActive) {
          scenario.step = node.logic.degreeToStep(node.angle, 4)
        }
      })

      updateDiagram()
    }

    function splitFile(result) {
      const [keys, ...rest] = result
        .trim()
        .split("\r\n")
        .map((item) => item.split(";"));

      return [keys, ...rest]
    }

    function extractFileData(keys, rest) {
      let deviceData = {}
      keys.forEach((key, index) => {
        deviceData[key] = rest.map((item) => {
          return parseFloat(item.at(index).replace(',', '.'))
        })
      })

      return deviceData
    }

    function parseFile(file) {
      const [keys, ...rest] = splitFile(file)
      config.energy_device_power = extractFileData(keys, rest)

      config.nodes.map((node) => {
        node.isActive = false
        node.logic = selectEnergyDevice(node.id)
        node.instanceId = 0
        nodeManager.addNode(node)
      })

      nodeManager.getNodes().map((node) => {
        tuioListener.connectTangibleToObject(node.tangible_id, node)
      })

      devArea.draw()
    }

    function selectEnergyDevice(energyDeviceId) {
      switch (energyDeviceId) {
        case 'trafo_classic':
          return new TrafoClassic();

        case 'trafo_d3':
          return new TrafoD3();

        case 'heatpump':
          let hp = new Heatpump()
          hp.historyInW = config.energy_device_power['hp']
          return hp;

        case 'crane':
          let crane = new Crane()
          crane.historyInW = config.energy_device_power['crane']
          return crane

        case 'office_building':
          let office_building = new OfficeBuilding()
          office_building.historyInW = config.energy_device_power['office_building']
          return office_building

        case 'pv_system':
          let pv = new PVSystem()
          pv.scaleFactor = 200
          pv.historyInW = config.energy_device_power['pv_system']
          return pv

        case 'battery':
          let battery = new Battery()
          battery.scaleFactor = 1
          battery.historyInW = config.energy_device_power['battery']
          return battery

        case 'wallbox':
          let wallbox = new Wallbox()
          wallbox.scaleFactor = 5
          wallbox.historyInW = config.energy_device_power['wallbox']
          return wallbox

        case 'clock':
          return new Clock(tuioListener, 12)

        case 'magnifying_glass':
          return new MagnifyingGlass()

        case 'forecasts':
          return new Forecasts()

        case 'qems':
          return new EnergyManagementSystem()

        default:
          return null;
      }
    }

    function dragNodeStarted(event) {
    }

    function draggedNode(event, d) {
      d3.select(this.parentNode)
        .attr("transform", d => `translate(${event.x}, ${event.y})`)
    }

    function dragNodeEnded(event, d) {
      console.log("dragended")
      let tuioObject = new Tuio11Object(Date.now(), -1, d.tangible_id, event.x / width, event.y / height, -1, -1, -1, -1, -1, -1)
      tuioObject.instanceId = d.instanceId
      d.x = event.x
      d.y = event.y
      d3.select("#scrollSVG-" + d.instanceId).attr("x", event.x).attr("y", event.y)
      nodeManager.updateNode(d)
      tuioListener.updateTuioObject(tuioObject)
    }

    function deleteNode(node) {
      tuioListener.removeTuioObject(node)
      nodeManager.removeNode(node)
      scenario.removeEnergyDevice(node.instanceId)
      updateDiagram()
    }

    function updateElectricityLines() {
      let electricityLinks = nodeManager.createElectricityLinks()
      scenario.setElectricityLinks(electricityLinks)

      d3.selectAll("#electricitylines")
        .selectAll(".electricityline")
        .data(electricityLinks)
        .join(
          enter => enter
            .append("line")
            .classed('electricityline', true)
            .classed('stroke-dashed-animated', d => nodeManager.isD3ActiveAndEnergyFlowing(d.sourceRef.logic, d.targetRef.logic))
            // .attr('x1', d => d.sourceRef.x)
            // .attr('y1', d => d.sourceRef.y)
            // .attr('x2', d => d.targetRef.x)
            // .attr('y2', d => d.targetRef.y)
            .attr('x2', d => nodeManager.determineEnergySource(d).x)
            .attr('y2', d => nodeManager.determineEnergySource(d).y)
            .attr('x1', d => nodeManager.determineEnergyTarget(d).x)
            .attr('y1', d => nodeManager.determineEnergyTarget(d).y),

          update => update
            // .call(d => { console.log("Updating lines"); console.log(d) })
            .classed('stroke-dashed-animated animation-reverse', d => nodeManager.isD3ActiveAndEnergyFlowing(d.sourceRef.logic, d.targetRef.logic))
            .attr('x2', d => nodeManager.determineEnergySource(d).x)
            .attr('y2', d => nodeManager.determineEnergySource(d).y)
            .attr('x1', d => nodeManager.determineEnergyTarget(d).x)
            .attr('y1', d => nodeManager.determineEnergyTarget(d).y),

          exit => exit
            // .call(d => { console.log("Exiting lines"); console.log(d) })
            .remove(),
        )

      d3.selectAll('.electricityline')
        .classed("stroke-[6px] stroke-gray-800", true)
    }

    function updateDataLines() {
      d3.selectAll("#datalines")
        .selectAll(".dataline")
        .data(nodeManager.createDataLinks())
        .join(
          enter => enter
            // .call(d => { console.log("Entering lines"); console.log(d) })
            .append("line")
            .classed('dataline stroke-[15px] stroke-green-400 drop-shadow-lg stroke-dashed animate-pulse', true)
            .attr("id", d => d.id)
            .attr('x1', d => d.sourceRef.x)
            .attr('y1', d => d.sourceRef.y)
            .attr('x2', d => d.targetRef.x)
            .attr('y2', d => d.targetRef.y),

          update => update
            // .call(d => { console.log("Updating lines"); console.log(d) })
            .attr('x1', d => d.sourceRef.x)
            .attr('y1', d => d.sourceRef.y)
            .attr('x2', d => d.targetRef.x)
            .attr('y2', d => d.targetRef.y),

          exit => exit
            // .call(d => { console.log("Exiting lines"); console.log(d) })
            .remove()
        )
    }

    function updateCommunicationLines() {
      let currentNodes
      d3.selectAll("#communicationLines")
        .selectAll(".communicationLine")
        .data(scenario.getCurrentCommunicationLinks())
        .join(
          enter => enter
            .append("line")
            .classed("communicationLine", true)
            .attr("stroke", "black")
            .attr("stroke-width", 4)
            .attr("stroke-dasharray", "5,5")
            .attr("stroke-opacity", 1)
            .attr("id", d => d.id)
            .attr('x1', d => d.sourceRef.x)
            .attr('y1', d => d.sourceRef.y)
            //.attr('x2', d => d.targetRef.x)
            .attr('x2', function (d) {
              if (d.targetRef === undefined) {
                return d.sourceRef.x
              }
              return d.targetRef.x
            })
            .attr('y2', function (d) {
              if (d.targetRef === undefined) {
                return d.sourceRef.y
              }
              return d.targetRef.y
            })
            .attr("marker-end", "url(#endArrow)"),

          update => {

            update
              .attr('x1', d => d.sourceRef.x)
              .attr('y1', d => d.sourceRef.y)
              .attr('x2', function (d) {
                if (d.targetRef === undefined) {
                  return d.sourceRef.x
                }
                return d.targetRef.x
              })
              .attr('y2', function (d) {
                if (d.targetRef === undefined) {
                  return d.sourceRef.y
                }
                return d.targetRef.y
              })
          },

          exit => exit
            .remove()
        )
    }

    function updateNodes() {
      let labelText
      d3.select("#nodes")
        .selectAll(".node")
        .data(nodeManager.getActiveNodes(), d => d.instanceId)
        .join(
          enter => {
            //console.log(nodeManager.getActiveNodes())
            let page1 = true
            let labelName
            let startX
            let offY = 0
            let nodeGroup = enter
              .append("g")
              .attr("id", d => d.id)
              .classed("node", true)
              .attr("transform", d => `translate(${d.x}, ${d.y})`)

            let nodeTypeDependantContent = nodeGroup
              .select(function (d) {
                return d.logic.drawCustomElements(this)
              })

            let nodeCircle = nodeGroup
              .append("circle")
              .attr("r", 20)
              .attr('class', d => `fill-[${d.color}]`)
              .classed('stroke-2 stroke-black', true)
              .call(d3.drag()
                .on("start", dragNodeStarted)
                .on("drag", draggedNode)
                .on("end", dragNodeEnded))

            let nodeCircleText = nodeGroup
              .append("text")
              .attr("dx", -15)
              .attr("dy", 5)
              .classed('font-mono fill-black text-xs', true)
              .text(d => d.short_label)
              .call(d3.drag()
                .on("start", dragNodeStarted)
                .on("drag", draggedNode)
                .on("end", dragNodeEnded))

            let nodeLabel = nodeGroup
              .append("g")
              //.attr("transform", d => `translate(-100, 40)`)
              .attr("transform", function (d) {
                let x = 0
                let y = 40
                if (globalThis.window.innerWidth / 12 < 190) {
                  x = -(190)
                }
                x = -(globalThis.window.innerHeight / 12)
                return `translate(${x}, ${y})`
              })
              .attr("id", d => "nodeLabel-" + d.instanceId)
              .classed("classic", d => d.logic.isTypeOf(NodeType.energyDevice) || d.logic.isTypeOf(NodeType.io))
              .classed("ems", d => d.logic.isTypeOf(NodeType.ems))
              .classed("smart", d => d.logic.isTypeOf(NodeType.smart))
              .classed("ui", d => d.logic.isTypeOf(NodeType.io))
              .classed("invisible", d => d.isLabelHidden)
              .classed("labelGroup", true)

            let labelRect = nodeLabel
              .append("rect")
              .attr("width", 420)
              .attr('height', 40)
              .attr("id", d => "labelRect-" + d.instanceId)
              .classed("nodeLabel", true)
              .attr('rx', '3')
              .on("wheel", function (event, d) {
                if (d.page === 2) {

                  event.preventDefault()

                  let scrollHeight = event.deltaY
                  offY = offY - scrollHeight

                  let contentHeight = Object.keys(d.agentView).length * 40
                  let maxScroll = 0
                  let minScroll = (globalThis.window.innerHeight / 4) - contentHeight

                  offY = Math.min(maxScroll, Math.max(minScroll, offY))
                  d3.select("#svgContainer-" + d.instanceId).attr("transform", "translate(0," + offY + ")")
                }
              })

            labelRect.select((d) => {
              if (d.logic.isTypeOf(NodeType.energyDevice)) {
                labelRect.classed("energyDevice", true)
              }
            })

            labelText = nodeLabel
              .append("text")
              .attr("id", d => "text-" + d.instanceId)
              .attr("x", 5)
              .attr("y", 20)
              .classed('text-2xl', true)
              .classed("invisible", false)
              .classed("labelText", true)
              .text(function (d) { return d.name })

            labelRect.select(d => {
              if (d.logic.isTypeOf(NodeType.smart)) {
                const co2Label = nodeLabel
                  .append("g")
                  .classed("ems-dependant-view invisible", true)
                  .attr("transform", d => `translate(${labelRect.attr("width") - 95}, 7) scale(1)`)

                co2Label
                  .append("rect")
                  .classed("stroke-[1.5px] stroke-green-400", true)
                  .attr('width', 75)
                  .attr('height', 25)
                  .attr('rx', '3')

                co2Label
                  .append("text")
                  .classed("fill-green-400 text-base font-semibold font-normal", true)
                  .text("-CO₂")
                  .attr("x", 29)
                  .attr("y", 18)

                co2Label
                  .append("path")
                  .attr("transform", d => `translate(2, 0) scale(1)`)
                  .classed("stroke-green-400 fill-none stroke-[1.5px]", true)
                  .attr("d", globalThis.config.ui.icons.globe_europe_africa)
              }
            })

            labelText.select(d => {
              toMultilineText(labelText, d.description, labelRect.attr("width") * 0.11 - 19, "text-base font-normal", 15)
            })
            labelText
              .insert("tspan", ":first-child")
              .text(" ")
              .attr("x", 0)
              .attr("dy", "0.5em")

            nodeLabel.select((d) => {
              if (d.logic.isTypeOf(NodeType.energyDevice)) {
                nodeLabel.append((d) => {

                  let tile = new TileIconTextGroup()
                  tile.idClass = "tile"
                  tile.width = 150
                  tile.height = 60
                  tile.x = labelRect.attr('width') - 160
                  tile.y = 46
                  tile.textHead = d.logic.nowInW >= 0 ? "Verbrauch" : "Erzeugung"
                  tile.textValue = Math.abs(Math.round((d.logic.nowInW / 1000)))
                  tile.cssValue = "d3-dependant-view"
                  tile.textUnit = "kW"
                  tile.iconPath = globalThis.config.ui.icons.bolt
                  tile.draw()
                  return tile.element.node()
                })
              }
            })


            enter.selectAll(".tile-text-head")
              .classed("fill-gray-200 text-base font-normal", true)

            enter.selectAll(".tile-text-value")
              .classed("fill-white text-2xl font-bold", true)

            enter.selectAll(".tile-text-unit")
              .classed("fill-white text-2xl font-bold", true)

            let labelHeight = (labelText.selectChildren("tspan").size() * 22) + 22
            if (labelHeight < 120) {
              labelHeight = 120
            }

            labelRect
              .attr("height", labelHeight)

            let diagram = nodeLabel
              .append("g")
              .attr("transform", d => `translate(40, 130)`)
              .attr("id", d => "diagram-" + d.instanceId)
              .classed("invisible", false)
              .classed("diagram d3-dependant-view", true)

            enter.select((d) => {
              if (d.logic.isTypeOf(NodeType.energyDevice) && !d.logic.isTypeOf(NodeType.trafo)) {
                d.logic.drawLoadDiagram(scenario.step, diagram)
              }
            })


            return nodeGroup;
          },

          // apply on given data
          update => {
            update
              .attr("transform", d => `translate(${d.x}, ${d.y})`)

            update.select(".tile-text-value")
              .text(d => Math.abs(Math.round(d.logic.nowInW / 1000)))

            update.select(".tile-text-head")
              .text(d => d.logic.nowInW >= 0 ? "Verbrauch" : "Erzeugung")

            update.select(".diagram")
              .classed("invisible", !nodeManager.isNodeActive('trafo_d3'))

            update.select((d) => {
              if (d.agentID && !inSimulation) {
                inSimulation = true
                //scenario.scenarioSteps = Object.keys(simulation).length + 1
                nodeManager.inSimulation = true
                let activeNodes = nodeManager.getPureActiveEnergyDevices()
                scenario.activeNodes = activeNodes
                //d3.select("#mainSVG").attr("class", "bg-black")
                d3.selectAll(".closeWindow").remove()
                d3.selectAll(".closeWindowText").remove()
                d3.selectAll(".tile").remove()
                d3.selectAll(".nodeLabel").attr("width", 300)
                d3.selectAll(".labelText").selectAll("tspan").remove()
              }
            })

            update.select((d) => {
              if (inSimulation) {
                if (d.page == 1) {
                  if (d3.selectAll(".agentView")) {
                    d3.selectAll(".agentView-" + d.instanceId).remove()
                  }
                  if (nodeManager.isNodeActive("trafo_d3")) {
                    d3.select("#diagram-" + d.instanceId).classed("invisible", false)
                    d3.select("#diagram-" + d.instanceId).classed("diagram d3-dependant-view", true)
                  }
                } else if (d.page == 2) {
                  d3.select("#text-" + d.instanceId).selectAll("tspan").remove()
                  d3.select("#diagram-" + d.instanceId).classed("invisible", true)
                  d3.select("#diagram-" + d.instanceId).classed("diagram d3-dependant-view", false)
                }
              }
            })

            update.select((d) => {
              if (inSimulation) {
                if (currentStep !== scenario.step) {
                  d3.selectAll(".agentViewAll").remove()
                  nodeManager.setAllPagesToZero()
                  currentStep = scenario.step
                }
                let currentCommunication = scenario.getCurrentCommunicationLinks()
                let currentConfiguration = scenario.getCurrentConfiguration()
                if (scenario.getCurrentStep() !== -1) {
                  if (currentConfiguration !== undefined && currentConfiguration.get(d.instanceId)) {
                    if (currentCommunication.find(node => node.sourceRef.instanceId === d.instanceId) || currentCommunication.find(node => node.targetRef.instanceId === d.instanceId)) {
                      createAgentView(d3.select("#nodeLabel-" + d.instanceId), d.instanceId, Object.fromEntries(currentConfiguration.get(d.instanceId)), true, null)
                    }
                  }
                }
                let manipulatedAgents
                if (scenario.getAttackScenario() == 1) {
                  try {
                    for (let value of currentConfiguration.entries()) {
                      for (let i = 0; i < value[1].length; i++) {
                        if (parseInt(value[1][i]) === 15) {
                          d3.select("#labelRect-" + value[0]).style("fill", "red")
                          break
                        } else {
                          d3.select("#labelRect-" + value[0]).style("fill", "grey")
                        }
                      }
                    }
                  } catch (error) {
                    console.log(error)
                  }
                }

                if (scenario.getAttackScenario() == 1 && scenario.getCurrentStep() !== -1) {

                  let nodes = nodeManager.getActiveInstances()
                  for (let o = 0; o < nodes.length; o++) {
                    console.log(currentConfiguration.has(1519))
                    console.log(nodes[o].instanceId)
                    if (!currentConfiguration.has(nodes[o].instanceId)) {
                      console.log("in")
                      d3.select("#labelRect-" + nodes[o].instanceId).style("fill", "grey")
                    }
                  }
                }

                if (currentStep !== -1) {
                  let currentSender = currentCommunication[0].sourceRef
                  let receivers = []
                  currentCommunication.forEach((message) => {
                    receivers.push(message.target)
                  })
                }
              }
            })

            update.select((d) => {
              if (d.logic.isTypeOf(NodeType.energyDevice) && !d.logic.isTypeOf(NodeType.trafo)) {
                d.logic.drawLoadDiagram(scenario.step)
              }
            })
            return update
          },

          // apply on deleted data
          exit => exit
            .remove()
        )
    }

    function updateDiagram() {
      scenario.calculateScenarioD3()
      sidebar.update()

      updateDataLines()
      updateElectricityLines()
      updateNodes()
      time.update()
      updateLabelClasses()
      updateInfoBoxes()
      if (inSimulation) {
        updateCommunicationLines()
      }
    }

    function updateInfoBoxes() {
      d3.select(tutorialPlaceDevices.element).node()
        .classed("invisible", scenario.getActiveNodes().length > 0)

      d3.select("#infobox-d3")
        .classed("invisible", nodeManager.isNodeActive("trafo_d3"))

      d3.select("#infobox-ems")
        .classed("invisible", (nodeManager.isNodeActive("trafo_d3") && nodeManager.isNodeActive("qems")))
    }

    function createAgentView(window, instanceId, data, keys, contentRow) {
      d3.selectAll(".agentView-" + instanceId).remove()
      nodeManager.setPage(parseInt(instanceId), 2)
      let content = data

      let container = window
        .append("g")
        .attr("id", "container-" + instanceId)
        .style("max-height", globalThis.window.innerHeight / 4 + 130)
        .style("overflow", "hidden")
        .style("border", "1px")
        .style("padding", "12px")
        .style("width", globalThis.window.innerWidth / 4.2)
        .classed("agentView-" + instanceId, true)
        .classed("agentViewAll", true)


      let svg = container
        .append("svg")
        .attr("id", "scrollSVG-" + instanceId)
        .attr("width", globalThis.window.innerWidth / 4)
        .attr("height", globalThis.window.innerHeight / 10 + 130)
        .style("max-height", globalThis.window.innerHeight / 10 + 130)
        .style("border", "1px solide white")
        .style("padding", "12px")
        .classed("agentView-" + instanceId, true)
        .classed("agentViewAll", true)

      svg
        .append("clipPath")
        .attr("id", "clip-" + instanceId)
        .append("rect")
        .attr("y", 30)
        .attr("width", globalThis.window.innerWidth / 4.2)
        .attr("height", globalThis.window.innerHeight / 4 + 130)
        .classed("agentView-" + instanceId, true)
        .classed("agentViewAll", true)

      let scrollGrp = svg
        .append("g")
        .attr("clip-path", "url(#clip-" + instanceId + ")")
        .classed("agentView-" + instanceId, true)
        .classed("agentViewAll", true)

      let svgContainer = scrollGrp
        .append("g")
        .attr("id", "svgContainer-" + instanceId)
        .attr("transform", "translate(0,0)")
        .attr("agentViewExpanded", false)
        .classed("agentView-" + instanceId, true)
        .classed("agentViewAll", true)

      let key = svgContainer
        .selectAll(".key-item")
        .data(function () {
          if (keys == true) {
            return Object.keys(data)
          }
          if (keys == false) {
            return Object.values(data)[contentRow]
          }
        })
        .classed("agentView-" + instanceId, true)
        .classed("agentViewAll", true)
        .enter()
        .append("g")
        .attr("class", "key-item")
        .style("cursor", "pointer")
        .on("click", function (d) {
          switchAgentView(d, data)
        })

      if (contentRow !== null) {
        let text = key
          .append("text")
          .text("")
          .attr("x", 10)
          .attr("y", 45)
          .attr("fill", "white")
          .attr("font-size", "1rem")
          .attr("line-height", "1.5rem")
          .classed("font-weight", 400)
          .on("click", function () {
            createAgentView(window, instanceId, data, true, null)
          })

        text
          .append("tspan")
          .text("Die Sicht des obenstehenden")

        text
          .append("tspan")
          .attr("dy", "1.2em")
          .attr("x", 10)
          .text("Agenten zum aktuellen Zeitpunkt")
      }

      key.each(function (d, i) {
        let curr = d3.select(this)
        i = i + 1
        curr
          .append("text")
          .attr("id", "plus-" + instanceId + "-" + i)
          .attr("x", 10)
          .attr("y", function () {
            if (contentRow == null) {
              if (i == 0) {
                return 40
              } else {
                return i * 30 + 40
              }
            }
            return i * 30 + 65
          })
          .text(function () {
            if (contentRow == null) {
              return "+"
            }
            if (contentRow !== null) {
              return "-"
            }
          }
          )
          .attr("fill", "white")
          .attr("font-size", "1rem")
          .attr("line-height", "1.5rem")
          .classed("font-weight", 400)
          .classed("agentView-" + instanceId, true)
          .classed("agentViewAll", true)
          .on("click", function () {
            if (contentRow !== null) {
              createAgentView(window, instanceId, data, true, null)
            }
          })

        curr
          .append("text")
          .attr("id", "plusText-" + instanceId + "-" + i)
          .attr("x", 25)
          .attr("y", function () {
            if (contentRow == null) {
              if (i == 0) {
                return 40
              } else {
                return i * 30 + 40
              }
            }
            return i * 30 + 65
          })
          .text(function () {
            if (contentRow === null) {
              return "Status von Agent: " + d
            }
            return i + ": " + d
          })
          .attr("fill", "white")
          .attr("font-size", "1rem")
          .attr("line-height", "1.5rem")
          .attr("agentViewExpanded", false)
          .classed("font-weight", 400)
          .classed("agentView-" + instanceId, true)
          .classed("agentViewAll", true)
          .on("click", function () {
            if (contentRow !== null) {
              createAgentView(window, instanceId, data, true, null)
            }
          })
      })

      let offY = 0

      svg.on("wheel", function (event) {
        event.preventDefault()

        let scrollHeight = event.deltaY
        offY = offY - scrollHeight

        let contentHeight = Object.keys(data).length * 40
        let maxScroll = 0
        let minScroll = (globalThis.window.innerHeight / 4) - contentHeight

        offY = Math.min(maxScroll, Math.max(minScroll, offY))
        svgContainer.attr("transform", "translate(0," + (30 + offY) + ")")
      })
    }

    function switchAgentView(d, data) {
      let instanceId
      let help = d.srcElement.id.split("-")
      let contentRow
      if (d.srcElement.id) {
        instanceId = help[1]
        contentRow = help[2]
      }
      if (instanceId) {
        let select = d3.select("#plus-" + instanceId + "-" + contentRow)
        let currSymbol = select.text()
        let currAgentViewExpandedText = d3.select("#svgContainer-" + instanceId).attr("agentViewExpanded")
        let currAgentViewExpanded
        if (currAgentViewExpandedText == "true") {
          currAgentViewExpanded = true
        } else {
          currAgentViewExpanded = false
        }
        if (currSymbol == "+" && !currAgentViewExpanded) {
          select.text("-")
          d3.select("#svgContainer-" + instanceId).attr("agentViewExpanded", true)
          d3.selectAll(".agentView-" + instanceId).remove()
          createAgentView(d3.select("#nodeLabel-" + instanceId), instanceId, data, false, contentRow - 1)
          //createAgentViewContainer(instanceId, contentRow)
        } else if (currSymbol == "-" && currAgentViewExpanded) {
          select.text("+")
          d3.select("#svgContainer-" + instanceId).attr("agentViewExpanded", false)
          //delete AgentViewContainer
        }
      }
    }

    function updateLabelClasses() {

      applyDefaultOnClassicAndUi()
      if (nodeManager.isNodeActive('trafo_d3')) {
        applyD3Stlye()
      } else {
        applyClassicStyle()
      }
      applyEmsStyle()
      applyColorsOnDiagramStrokes()
      applyD3DependantContent()
      applyD3AndEmsDependantContent()
      applyPrognosisDependantContent()

      function applyDefaultOnClassicAndUi() {
        d3.selectAll(".labelGroup").filter(".classic.ui").selectAll("rect")
          .classed(globalThis.config.ui.classes.node_label_classic_rect, true)
      }

      function applyD3Stlye() {
        d3.selectAll(".labelGroup").filter(".classic").filter(":not(.ui)").selectAll("rect")
          .classed(globalThis.config.ui.classes.node_label_classic_rect, !nodeManager.isNodeActive('trafo_d3'))
          .classed(globalThis.config.ui.classes.node_label_d3_rect, nodeManager.isNodeActive('trafo_d3'))

        d3.selectAll(".labelGroup").filter(".classic").filter(":not(.ui)").select("rect")
          .attr("height", d => {
            if (inSimulation) {
              if (d.page === 1) {
                return 40
              } else if (d.page === 2) {
                return globalThis.window.innerHeight / 10 + 130
              }
              return globalThis.window.innerHeight / 10 + 120
            } else {
              if (!d.logic.isTypeOf(NodeType.trafo)) {
                return 260
              }
              return d3.selectAll(".labelGroup").filter(".classic").selectAll("rect").node().getBBox().height
            }
          })

        d3.selectAll(".labelGroup").filter(".classic").select("text")
          .classed(globalThis.config.ui.classes.node_label_classic_text, false)
          .classed(globalThis.config.ui.classes.node_label_d3_text, true)

      }

      function applyClassicStyle() {
        d3.selectAll(".labelGroup").filter(".classic").selectAll("rect")
          .classed(globalThis.config.ui.classes.node_label_d3_rect, false)
          .classed(globalThis.config.ui.classes.node_label_classic_rect, true)

        d3.selectAll(".labelGroup").filter(".classic").select("rect")
          .attr("height", d => {
            if (inSimulation) {
              if (d.page === 0) {
                return 40
              } else if (d.page === 2) {
                return globalThis.window.innerHeight / 10 + 130
              }
              return 120
            } else {
              if (!d.logic.isTypeOf(NodeType.trafo)) {
                return
              }
              return d3.selectAll(".labelGroup").filter(".classic").selectAll("rect").node().getBBox().height
            }

          })

        d3.selectAll(".labelGroup").filter(".classic").select("text")
          .classed(globalThis.config.ui.classes.node_label_d3_text, false)
          .classed(globalThis.config.ui.classes.node_label_classic_text, true)

      }

      function applyEmsStyle() {
        d3.selectAll(".labelGroup").filter(".ems").select("rect")
          .classed(globalThis.config.ui.classes.node_label_ems_rect, true)

        d3.selectAll(".labelGroup").filter(".ems").select("text")
          .classed(globalThis.config.ui.classes.node_label_ems_text, true)
      }

      function applyD3DependantContent() {
        d3.selectAll(".d3-dependant-view").classed("invisible", function (d) {
          if (inSimulation) {
            try {
              if (d.page === 0) {
                return true
              } else {
                return !nodeManager.isNodeActive("trafo_d3")
              }
            } catch (error) {
              return !nodeManager.isNodeActive("trafo_d3")
            }
          } else {
            return !nodeManager.isNodeActive("trafo_d3")
          }
        })
      }

      function applyD3AndEmsDependantContent() {
        d3.selectAll(".ems-dependant-view")
          .classed("invisible", !nodeManager.isNodeActive("trafo_d3") || !nodeManager.isNodeActive("qems"))
      }

      function applyPrognosisDependantContent() {
        d3.selectAll(".prognosis-dependant-view")
          .classed("invisible", !nodeManager.isNodeActive("forecasts"))
      }

      function applyColorsOnDiagramStrokes() {
        if (nodeManager.isNodeActive('qems')) {

          d3.selectAll(".labelGroup").filter(".smart").select(".diagram").select(".diagram-historical")
            .classed("stroke-white", false)
            .classed("stroke-green-400", true)

        } else {
          d3.selectAll(".labelGroup").filter(".smart").select(".diagram").select(".diagram-historical")
            .classed("stroke-green-400", false)
            .classed("stroke-white", true)
        }
      }
    }




    // Variables

    // Declare the chart dimensions and margins.
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Create the SVG container.
    const svg = d3.create("svg")
      .attr("id", "mainSVG")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr('class', 'h-full w-full')
      .attr('class', 'bg-[url("./images/bg-blue_big.webp")] bg-cover border-solid border-black border-2 border-blue-400')

    const sidebar = new SideBarSmall(svg, nodeManager, tuioListener, scenario)
    sidebar.x = width
    sidebar.y = height

    const devArea = new DevArea(svg, nodeManager, tuioListener)

    const tutorialPlaceDevices = new InfoBox("infobox-begin")
    tutorialPlaceDevices.width = 800
    tutorialPlaceDevices.height = 200
    tutorialPlaceDevices.x = width / 2 - tutorialPlaceDevices.width / 2
    tutorialPlaceDevices.y = height / 2 - tutorialPlaceDevices.height / 2
    tutorialPlaceDevices.rectCss = "stroke-0 stroke-black fill-[#252e42]/90"
    tutorialPlaceDevices.textHead = "Willkommen"
    tutorialPlaceDevices.textHeadCss = "fill-white text-3xl font-bold"
    tutorialPlaceDevices.textContent = "Bitte platzieren Sie ein Energiegerät auf dem Industrieareal."
    tutorialPlaceDevices.textContentCss = "fill-white font-normal"
    tutorialPlaceDevices.draw()

    svg
      .append(function () { return tutorialPlaceDevices.element.node(); })


    // Add nodes group
    var nodeNetwork = svg
      .append("g")
      .attr("id", "nodeNetwork")

    // Add circles
    const node = nodeNetwork
      .append("g")
      .attr("id", "nodes")



    var commLinks = svg
      .append("g")
      .attr("id", "communicationLines")

    let letterInfo = svg
      .append("g")
      .attr("id", "letterInfo")
      .attr("transform", `translate(150, 150)`)

    // Add lines first, in order to have the circles in the top
    var dataLinks = nodeNetwork
      .append("g")
      .attr("id", "datalines")

    var link = nodeNetwork
      .append("g")
      .attr("id", "electricitylines")

    commLinks
      .append("defs")
      .append("marker")
      .attr("id", "endArrow")
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 20)
      .attr("refY", 5)
      .attr("markerWidth", 5)
      .attr("markerHeight", 5)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", "red")

    const time = new Time(svg, scenario)

    // Script
    initiateApplicationStart();
    demonstratorContainer.append(svg.node());
  </script>

</head>

<body class="touch-none h-14 bg-gradient-to-r from-sky-500 to-[#1182c2] select-none">

  <div id="demonstratorContainer"></div>

</body>

</html>